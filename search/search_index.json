{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AVVV ETSI Documentation","text":""},{"location":"#about-avvv","title":"About AVVV","text":"<p>The AVVV project, standing for Autonomous Vehicle V2X Visualiser, aims to analyse and visualise V2X communications. V2X refers to the communications between the autonomous vehicle and everything else, including the road-side units (RSUs) and other intelligent vehicles (On-boar units or OBUs, for short).</p> <p>When the autonomous vehicle is navigating in the streets, it perceives its environment. It specifically detects and predicts pedestrians and other vehicles on the road and traffic lights and signs. The vehicle then makes decisions based on these detections. The autonomous vehicle can communicate its perception data via some network means dedicated to this purpose, to other intelligent vehicles and entities on the road. This cooperation can dramatically increase planning and navigation accuracy and road safety for all users.</p> <p>The road-side units abbreviated as RSUs are enabled to accurately monitor roads and perform the same perception as intelligent vehicles using their state-of-the-art sensors and algorithms. Therefore, apart from the vehicle-to-vehicle communication, the vehicle-to-RSU communication also offers beneficial possibilities.</p> <p>The V2X communications are done through ROS messages. These messages are then transmitted from the source to the destination as UDP packets. Like any ordinary network packet, these packets can get lost in the network or arrive at the target late. The AVVV\u2019s mission is to analyse these latencies and packet losses and visualise them in a user-friendly manner.</p> <p>In AVVV, we investigate the object prediction communications between one or more target vehicles and one or more RSUs. The investigation covers network aspects and parameters such as delay, packet loss, jitter and RSSI.</p> <p>Delay refers to the time it takes for the packets to transmit from the sender and reach the receiver. Using the DSRC (Dedicated Short-Range Communication) network, the delay will consist of the propagation and transmission delays. Whereas, using the cellular network, it will additionally include the queueing and processing delays in the intermediate routers. Many factors can impact delay; bandwidth, MAC protocol, distance between the sender, the intermediate routers and the receiver, velocity of signals in various media, congestion in network and servers\u2019 processing speed are a few to name.</p> <p>Packet loss occurs when the transmitted packets fail to reach the intended receiver. Some causes of packet loss are network congestion, software bugs, hardware failure and security threats.</p> <p>Jitter is a term used to describe variations in network latency (delay). Jitter is higher when data are received at irregular delays. The same delay causes can contribute to jitter as well, plus signal inferences.</p> <p>Received Signal Strength Indicator (RSSI), in summary, represents how well the receiver gets the transmitted data. It determines the strength of the signal received by the receiver. It is a relative value which IEEE 802.11 specifies to be between 0 and 255.</p> <p>RSUs and OBUs broadcast their data based on the ETSI standard in the format of Collective Perception Messages (CPMs). Visit the ETSI official document for more information about ETSI and the CPM format.</p>"},{"location":"#getting-started","title":"Getting started","text":"<ul> <li>Installation pages explain the installation steps of AVVV.</li> <li>Tutorials pages explain several tutorials that you should try after installation.</li> <li>How-to guides pages explain advanced topics that you should read after you get comfortable with AVVV.</li> <li>Design pages explain the design concept of AVVV.</li> <li>protocols pages explain protocols used.</li> <li>Datasets pages contain information about datasets that can be used with AVVV.</li> <li>Support pages explain several support resources.</li> </ul>"},{"location":"datasets/","title":"Datasets","text":""},{"location":"design/","title":"AVVV's Design","text":""},{"location":"how-to-guides/","title":"How-to guides","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>This is a source installation. It requires: - OS: Ubutnu 22.04 - ROS: ROS2 Humble - Git</p>"},{"location":"installation/#build","title":"Build","text":"<p>Take the steps as they're provided below in all sections:</p> <p>Initially perform an update: <pre><code>sudo apt update\n</code></pre></p> <p>Clone this repository: <pre><code>git clone git@github.com:tlab-wide/avvv_etsi.git\n</code></pre></p> <p>Navigate to the root directory: <pre><code>cd avvv_etsi\n</code></pre></p>"},{"location":"installation/#analyser","title":"Analyser","text":"<p>Navigate to <code>lib/wireshark</code>: <pre><code>cd lib/wireshark\n</code></pre></p> <p>Setup Wireshark build: <pre><code>sudo sh tools/debian-setup.sh\n</code></pre></p> <p>Create a new directory named <code>build</code> and navigate to it: <pre><code>mkdir build &amp;&amp; cd build\n</code></pre></p> <p>Configure and build Wireshark: <pre><code>cmake -DBUILD_wireshark=OFF ..\nmake\n</code></pre></p> <p>Navigate back to <code>lib</code>: <pre><code>cd ../..\n</code></pre></p> <p>Create a Python3 virtual environment: <pre><code>python3 -m venv ./avvv_etsi_venv\n</code></pre></p> <p>Activate the virtual environment: <pre><code>source avvv_etsi_venv/bin/activate\n</code></pre></p> <p>Navigate to <code>lib/pyshark/src</code>: <pre><code>cd pyshark/src\n</code></pre></p> <p>Install <code>pyshark</code> locally: <pre><code>python3 setup.py install\n</code></pre></p> <p>Navigate to the <code>analyser</code> directory:</p> <pre><code>cd ../../../analyser\n</code></pre> <p>Install the dependencies using pip:</p> <pre><code>pip3 install -r requirements.txt\n</code></pre>"},{"location":"installation/#visualiser","title":"Visualiser","text":"<p>Build the geographic library. From the root directory of the repository, navigate to <code>lib/geographiclib-2.3</code>:</p> <pre><code>cd lib/geographiclib-2.3\n</code></pre> <p>Create a new directory for building: <pre><code>mkdir build &amp;&amp; cd build\n</code></pre></p> <p>Configure, build and install GeographicLib:</p> <pre><code>cmake ..\nmake\nsudo make install\n</code></pre> <p>Navigate to the <code>visualiser</code> directory:</p> <pre><code>cd ../../visualiser\n</code></pre> <p>Resolve ROS2 dependencies using <code>rosdep</code>:</p> <pre><code>source /opt/ros/humble/setup.bash\nrosdep update\nrosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO\n</code></pre> <p>Build the whole workspace using <code>colcon</code>. While still in the visualiser directory run:</p> <pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release\n</code></pre>"},{"location":"installation/#launcher","title":"Launcher","text":"<p>Install Qt6 libraries and dependencies:</p> <pre><code>sudo apt install qt6-tools-dev qt6-wayland\n</code></pre> <p>Navigate to the <code>ui</code> directory located in the root directory:</p> <pre><code>cd ui/visually_launcher\n</code></pre> <p>Build the application:</p> <pre><code>cmake -S . -B build\nmake -C build -j4\n</code></pre>"},{"location":"installation/#build-troubleshoot","title":"Build Troubleshoot","text":"<ul> <li>In case you run into a SetupToolsDeprecationWarning issue when building any of the ROS packages, you need to downgrade you <code>setuptools</code> Python package using: <pre><code>pip3 install setuptools==58.2.0\n</code></pre> To make sure you have the right version of setuptools installed, execute the following: <pre><code>pip3 show setuptools\n</code></pre></li> </ul>"},{"location":"installation/#input-data","title":"Input Data","text":"<p>Basically, the analyser module takes in the ROSBAG and PCAP files and extracts the network information in form of reports and graphs and generates a single ROSBAG file for exhibition purposes.</p> <p>Considering all of your input files are ready and gathered in a single folder called, for instance, <code>input_files</code>, the structure of the input data should be such as the following:</p> <pre><code>input_files\n\u251c\u2500\u2500 pcap\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 OBU_0.pcap\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 OBU_2.pcap\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 RSU_0.pcap\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 RSU_1.pcap\n\u2502   ...\n\u2514\u2500\u2500 rosbag\n    \u251c\u2500\u2500 OBU_0\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 *.db3\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 metadata.yaml\n    \u251c\u2500\u2500 OBU_2\n    \u2502   \u251c\u2500\u2500 *.db3\n    \u2502   \u2514\u2500\u2500 metadata.yaml\n    \u251c\u2500\u2500 RSU_0\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 *.db3\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 metadata.yaml\n    \u251c\u2500\u2500 RSU_1\n    \u2502   \u251c\u2500\u2500 *.db3\n    \u2502   \u2514\u2500\u2500 metadata.yaml\n    ...\n</code></pre> <p>The <code>input_files</code> directory should be divided into 2 subdirectories called <code>pcap</code> and <code>rosbag</code> for comfort. The pcap files in <code>pcap</code> must be named after the name of their OBU or RSU IDs as in the figure above. <code>rosbag</code> must contain a directory named after their OBU or RSU IDs each containing a ROSBAG file corresponding to a PCAP file in <code>pcap</code>. There must exactly be one ROSBAG and PCAP file for each entity separately in <code>pcap</code> and <code>rosbag</code> and their names must match.</p> <p>The PCAP files must contain data in the ETSI 2019 standard format. Get the standards from here</p> <p>The input OBU ROSBAGs must contain the three essential topics: - /tf: Locating the OBU or the RSU over time (tf2_msgs/msg/TFMessage) - /perception/object_recognition/objects: The OBU's own predicted objects (autoware_auto_perception_msgs/msg/PredictedObjects) - /v2x/cpm/objects: The predicted objects the OBU has received from an RSU (autoware_auto_perception_msgs/msg/PredictedObjects)</p> <p>Likewise, the input RSU ROSBAGs must contain the following topics: - /tf: Locating the OBU or the RSU over time (tf2_msgs/msg/TFMessage) - /perception/object_recognition/objects: The RSU's own predicted objects (autoware_auto_perception_msgs/msg/PredictedObjects)</p> <p>A sample input data is provided with the package that you can explore.</p>"},{"location":"protocols/","title":"Protocols","text":"<p>This pages explains about protocols that used in the AVVV ETSI Project </p>"},{"location":"protocols/cpm_protocol/","title":"CPM","text":""},{"location":"protocols/cpm_protocol/#what-is-cpm-protocol","title":"What is CPM Protocol","text":"<p>The CPM (Collective Perception Message) protocol is a key component of the Collective Perception Service (CPS)  analyzed in ETSI TR 103 562 V2.1.1 (2019-12). The CPS is a service that enables vehicles to share information about their surroundings, such as road conditions, traffic, and weather, with other vehicles and infrastructure. The CPM protocol is used to format and transmit this information between vehicles and infrastructure. The CPM protocol is designed to be lightweight and efficient, allowing for the transmission of large amounts of data in real-time. The protocol includes a header and payload, with the header containing information about the message type, sender, and receiver, and the payload containing the actual data being transmitted. Overall, the CPM protocol is a key component of the CPS, enabling the exchange of information between  vehicles and infrastructure to improve safety, efficiency, and sustainability in transportation systems.</p>"},{"location":"protocols/cpm_protocol/#document","title":"Document","text":"<ul> <li>For a full description of the cpm protocol.</li> </ul>"},{"location":"protocols/its_protocol/","title":"ITS","text":""},{"location":"protocols/its_protocol/#that-is-its-protocol","title":"That is ITS  Protocol","text":"<p>The ITS (Intelligent Transport Systems) protocol is a communication protocol used in  transportation systems to enable the exchange of information between vehicles, infrastructure, and other devices.  The protocol is designed to improve safety, efficiency, and sustainability in transportation systems.</p>"},{"location":"protocols/its_protocol/#features","title":"Features","text":"<p>The ITS protocol includes the following features:</p> <ul> <li>Real-time communication: The protocol enables real-time communication between vehicles, infrastructure, and other devices, allowing for faster and more efficient transportation.</li> <li>Data exchange: The protocol enables the exchange of data between different devices, such as traffic signals, vehicles, and pedestrians, to improve safety and efficiency.</li> <li>Standardization: The protocol is standardized to ensure interoperability between different devices and systems, making it easier to implement and maintain.</li> <li>Security: The protocol includes security features to protect against unauthorized access and ensure the integrity of the data being exchanged.</li> </ul>"},{"location":"protocols/its_protocol/#applications","title":"Applications","text":"<p>The ITS protocol has a wide range of applications in transportation systems, including:</p> <ul> <li>Traffic management: The protocol can be used to manage traffic flow and reduce congestion by enabling real-time communication between traffic signals, vehicles, and other devices.</li> <li>Vehicle safety: The protocol can be used to improve vehicle safety by enabling communication between vehicles and infrastructure, such as warning drivers of potential hazards or providing information about road conditions.</li> <li>Public transportation: The protocol can be used to improve the efficiency and reliability of public transportation systems by enabling real-time communication between buses, trains, and other vehicles.</li> </ul>"},{"location":"protocols/its_protocol/#implementation","title":"Implementation","text":"<p>The ITS protocol can be implemented using a variety of communication technologies, including cellular networks, Wi-Fi, and dedicated short-range communication (DSRC). The protocol is typically implemented using a layered architecture, with different layers responsible for different aspects of the communication process.</p>"},{"location":"protocols/its_protocol/#conclusion","title":"Conclusion","text":"<p>The ITS protocol is a powerful tool for improving safety, efficiency, and sustainability in transportation systems. By enabling real-time communication and data exchange between different devices, the protocol can help to reduce congestion, improve vehicle safety, and enhance the overall transportation experience.</p>"},{"location":"support/","title":"Support","text":""},{"location":"tutorials/","title":"Simulation Tutorials","text":""}]}